#!/usr/bin/env node -r babel-register

import path from "path"
import { spawn } from "child_process"

import chalk from "chalk"
import Watchman from "fb-watchman"

const jsTestFilePattern = /\.test\.jsx?$/

function spawnProcessP({ name, args, execPath = process.execPath }) {
  return new Promise((resolve, reject) => {
    /* console.log({ name, execPath, args }) */
    console.log(
      chalk.blue(
        `>>> ${name}: ${execPath === process.execPath ? "node" : execPath} ${args.join(" ")}`,
      ),
    )
    spawn(execPath, args, { stdio: "inherit" })
      .on("error", err => {
        console.error(`error spawning ${name}`, err)
        reject(err)
      })
      .on("exit", code => {
        if (code === 0) {
          console.error(chalk.green(`<<< ${name} succeeded`))
        } else {
          console.error(chalk.red(`<<< ${name} exited ${code}`))
        }
        return resolve()
      })
  })
}

function promisify(fn) {
  return new Promise((resolve, reject) => {
    const cb = (error, response) => {
      // console.log({error, response})
      if (error) {
        reject(error)
      } else {
        resolve(response)
      }
    }
    fn(cb)
  })
}

class WatchmanManager {
  constructor(roots) {
    this.client = new Watchman.Client()
    this.roots = roots
  }

  async start() {
    await this.init()
    return Promise.all(
      this.roots.map(async rootConfig => {
        const { root, subscriptions } = rootConfig
        await this.watchProject({ root })
        return Promise.all(
          subscriptions.map(async ({ name, config, handlers = [] }) => {
            handlers.forEach(handler => {
              this.client.on("subscription", event => {
                const { subscription } = event
                if (subscription !== name) return
                /* console.log({ subscription, files: event.files }) */
                handler(event)
              })
            })
            await this.subscribe({ root, sub: config, name })
          }),
        )
      }),
    )
  }

  init() {
    return promisify(cb =>
      this.client.capabilityCheck({ optional: [], required: ["term-ipcre"] }, cb),
    )
  }

  async watchProject({ root }) {
    const resp = await promisify(cb => this.client.command(["watch-project", root], cb))

    if ("warning" in resp) {
      console.log("Watchman[WARNING]:", resp.warning)
    }

    /* console.log("watch established on", resp.watch) */

    return { resp }
  }

  async subscribe({ root, name, sub }) {
    const resp = await promisify(cb => this.client.command(["subscribe", root, name, sub], cb))

    if ("warning" in resp) {
      console.log("Watchman[WARNING]:", resp.warning)
    }

    return { resp }
  }

  stop() {
    this.client.removeAllListeners("subscription")
    this.client.end()
  }
}

class RunList {
  constructor() {
    this.list = new Set()
  }

  reset() {
    this.list.clear()
    this.all = false
  }

  runAll() {
    this.all = true
  }

  concat(files) {
    files.forEach(f => this.list.add(f))
  }

  value() {
    if (this.all) return "all"
    return Array.from(this.list)
  }

  any() {
    if (this.all) return true
    return this.list.size > 0
  }
}

class ProcessManager {
  constructor() {
    this.shouldExit = false
    this.queues = {} // keyed by process type, values are args to run next time we run this process type
    this.processes = {}
    this.process_priority = []
    this.timeout = null
  }

  schedule(type, files) {
    if (this.shouldExit) return
    if (!(type in this.processes)) throw new Error(`Process type ${type} is not known`)

    if (files === "all") {
      this.queues[type].runAll()
    } else {
      this.queues[type].concat(files)
    }

    /* console.log({ queues: JSON.stringify(this.queues, 2) }) */
    if (!this.timeout) {
      this.timeout = setTimeout(() => this.runNext(), 100)
    }
  }

  async runNext() {
    if (this.shouldExit) return

    const type = this.process_priority.find(t => this.queues[t].any())

    if (!type) {
      this.timeout = null
      return
    }

    const proc = this.processes[type]
    let files = this.queues[type].value()
    if (files === "all") files = proc.allArgs
    const args = proc.argsFn(files)

    this.queues[type].reset()

    await spawnProcessP({
      name: type,
      execPath: proc.execPath,
      args,
    })

    this.timeout = setTimeout(() => this.runNext(), 100)
  }

  defineProcess(type, { argsFn, execPath = process.execPath, allArgs = [] }) {
    if (type in this.processes) throw new Error(`Process "${type}" is already defined!`)
    this.processes[type] = {
      argsFn,
      execPath,
      allArgs,
    }
    this.process_priority.push(type)
    this.queues[type] = new RunList()
    return this
  }

  exit() {
    this.shouldExit = true
    return this.promiseChain
  }
}

const root = path.dirname(__dirname)
const procManager = new ProcessManager()
  .defineProcess("Prettier", {
    argsFn: files => ["node_modules/.bin/prettier", "--loglevel", "warn", "--write", ...files],
    allArgs: [".babelrc", ".eslintrc", "bin/test-watch", "**/*.{js,jsx,json,yaml,md}"],
  })
  .defineProcess("ESLint", {
    argsFn: files => ["node_modules/.bin/eslint", "--ext", "js,jsx", ...files],
    allArgs: [".", __filename],
  })
  .defineProcess("Jest", {
    argsFn: files => ["node_modules/.bin/jest", ...files],
    allArgs: [],
  })
  .defineProcess("Rubocop", {
    argsFn: files => ["bin/rubocop", ...files],
    allArgs: [],
    execPath: "ruby",
  })
  .defineProcess("Rails-Test", {
    argsFn: files => ["bin/rails", "test", ...files],
    allArgs: [],
    execPath: "ruby",
  })

const standardExclusions = [
  ["not", ["ipcre", "^(node_modules|tmp|log|public)", "wholename"]],
  ["not", ["ipcre", "^\\.#"]],
]

const prettierConfig = {
  name: "prettier",
  config: {
    expression: [
      "allof",
      [
        "anyof",
        ["ipcre", "\\.(jsx?|json|ya?ml|md)$"],
        ["match", ".eslintrc"],
        ["match", ".babelrc"],
        ["match", "test-watch"],
      ],
      ...standardExclusions,
    ],
    fields: ["name", "exists"],
  },
  handlers: [
    ({ files }) => {
      const runList = []
      const runAll = files.some(file => {
        if (path.basename(file.name) === ".prettierrc.js") return true
        if (file.exists) runList.push(file.name)
        return false
      })
      if (runList.length === 0) return
      if (runAll) {
        procManager.schedule("Prettier", "all")
      } else {
        procManager.schedule("Prettier", runList)
      }
    },
  ],
}

const lintConfig = {
  name: "lint",
  config: {
    expression: [
      "allof",
      ["anyof", ["ipcre", "(\\.jsx?|\\.eslintrc)$"], ["match", "test-watch"]],
      ...standardExclusions,
    ],
    fields: ["name", "exists"],
  },
  handlers: [
    ({ files, is_fresh_instance: isFresh }) => {
      if (isFresh) {
        procManager.schedule("ESLint", "all")
        return
      }
      const filesToLint = files
        .filter(f => f.exists)
        .map(f => (path.basename(f.name) === ".eslintrc" ? path.dirname(f.name) : f.name))
      if (filesToLint.length === 0) return
      procManager.schedule("ESLint", filesToLint)
    },
  ],
}

const testConfig = {
  name: "js-test",
  config: {
    expression: [
      "allof",
      ["anyof", ["ipcre", "^app/javascript/", "wholename"], ["ipcre", "^test-.+", "wholename"]],
      ["ipcre", ".jsx?$"],
      ...standardExclusions,
    ],
    fields: ["name", "exists"],
  },
  handlers: [
    ({ files }) => {
      const testFiles = []
      const runAll = files.some(file => {
        const isTestFile = jsTestFilePattern.test(file.name)
        if (!isTestFile) return true // if event includes any non-tests, short-circuit .some() to exit iteration and runAll = true
        if (file.exists) testFiles.push(file.name) // still existing test file, add to list
        return false
      })

      if (runAll) procManager.schedule("Jest", "all")
      if (testFiles.length > 0) procManager.schedule("Jest", testFiles)
    },
  ],
}

const rubyTestFilePattern = /_test\.rb$/
const rubyTestConfig = {
  name: "ruby-test",
  config: {
    expression: ["allof", ["ipcre", ".rb?$"], ...standardExclusions],
    fields: ["name", "exists"],
  },
  handlers: [
    ({ files, is_fresh_instance: isFresh }) => {
      if (isFresh) {
        procManager.schedule("Rails-Test", "all")
        return
      }

      const testFiles = []
      const runAll = files.some(file => {
        const isTestFile = rubyTestFilePattern.test(file.name)
        if (!isTestFile) return true // if event includes any non-tests, short-circuit .some() to exit iteration and runAll = true
        if (file.exists) testFiles.push(file.name) // still existing test file, add to list
        return false
      })

      if (runAll) procManager.schedule("Rails-Test", "all")
      if (testFiles.length > 0) procManager.schedule("Rails-Test", testFiles)
    },
  ],
}

const rubocopConfigFile = ".rubocop.yml"
const rubyLintConfig = {
  name: "ruby-lint",
  config: {
    expression: [
      "allof",
      ["anyof", ["ipcre", ".rb?$"], ["match", rubocopConfigFile]],
      ...standardExclusions,
    ],
    fields: ["name", "exists"],
  },
  handlers: [
    ({ files, is_fresh_instance: isFresh }) => {
      if (isFresh) {
        procManager.schedule("Rubocop", "all")
        return
      }

      const runList = []
      const runAll = files.some(file => {
        const isConfigFile = file.name === rubocopConfigFile
        if (isConfigFile) return true // if event includes config, lint all
        if (file.exists) runList.push(file.name)
        return false
      })

      if (runAll) procManager.schedule("Rubocop", "all")
      if (runList.length > 0) procManager.schedule("Rubocop", runList)
    },
  ],
}

const watchmanManager = new WatchmanManager([
  {
    root,
    subscriptions: [prettierConfig, lintConfig, testConfig, rubyLintConfig, rubyTestConfig],
  },
])

function exit() {
  console.log("exiting...")
  watchmanManager.stop()
  procManager.exit()
  process.stdin.pause()
  /* process.stdin.removeAllListeners("data") */
  /* process.exit() */
}

function main() {
  watchmanManager.start().catch(err => {
    console.log(err)
    exit()
  })

  process.stdin.resume()
  process.stdin.setEncoding("utf8")
  process.stdin.on("data", chunk => {
    switch (chunk.trim()) {
      case "":
        procManager.schedule("Prettier", "all")
        procManager.schedule("ESLint", "all")
        procManager.schedule("Jest", "all")
        procManager.schedule("Rubocop", "all")
        procManager.schedule("Rails-Test", "all")
        break
      case "t":
        procManager.schedule("Jest", "all")
        procManager.schedule("Rails-Test", "all")
        break
      case "p":
        procManager.schedule("Prettier", "all")
        break
      case "l":
        procManager.schedule("ESLint", "all")
        procManager.schedule("Rubocop", "all")
        break
      case "q":
        exit()
        break
      default:
        console.log({ chunk })
    }
  })

  process.on("SIGINT", exit)
}

main()
