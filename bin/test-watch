#!/usr/bin/env node -r babel-register

import path from "path"
import { spawn } from "child_process"

import chalk from "chalk"
import Watchman from "fb-watchman"

const testFilePattern = /\.test\.jsx?$/

function spawnProcessP({ name, args, execName = process.execPath }) {
  return new Promise((resolve, reject) => {
    console.log(
      chalk.blue(
        `>>> ${name}: ${execName === process.execPath ? "node" : execName} ${args.join(" ")}`,
      ),
    )
    spawn(execName, args, { stdio: "inherit" })
      .on("error", err => {
        console.error(`error spawning ${name}`, err)
        reject(err)
      })
      .on("exit", code => {
        if (code === 0) {
          console.error(chalk.green(`<<< ${name} succeeded`))
        } else {
          console.error(chalk.red(`<<< ${name} exited ${code}`))
        }
        return resolve()
      })
  })
}

function runPrettier(files) {
  return spawnProcessP({
    args: ["node_modules/.bin/prettier", "--loglevel", "warn", "--write", ...files],
    name: "Prettier",
  })
}

function runPrettierAll() {
  return runPrettier([".babelrc", ".eslintrc", "bin/test-watch", "**/*.{js,jsx,json,yaml,md}"])
}

function runLint(files) {
  return spawnProcessP({
    args: ["node_modules/.bin/eslint", "--ext", "js,jsx", ...files],
    name: "ESLint",
  })
}

function runLintAll() {
  return runLint(".")
}

function runJest(files) {
  return spawnProcessP({
    args: ["node_modules/.bin/jest", ...files],
    name: "Jest",
  })
}

function runJestAll() {
  return runJest([])
}

function promisify(fn) {
  return new Promise((resolve, reject) => {
    const cb = (error, response) => {
      // console.log({error, response})
      if (error) {
        reject(error)
      } else {
        resolve(response)
      }
    }
    fn(cb)
  })
}

class WatchmanManager {
  constructor(roots) {
    this.client = new Watchman.Client()
    this.roots = roots
  }

  async start() {
    await this.init()
    this.roots.forEach(async rootConfig => {
      const { root, subscriptions } = rootConfig
      await this.watchProject({ root })
      subscriptions.forEach(async ({ name, config, handlers = [] }) => {
        handlers.forEach(handler => {
          this.client.on("subscription", event => {
            const { subscription } = event
            if (subscription !== name) return
            /* console.log(event) */
            handler(event)
          })
        })
        await this.subscribe({ root, sub: config, name })
      })
    })
  }

  init() {
    return promisify(cb =>
      this.client.capabilityCheck({ optional: [], required: ["term-ipcre"] }, cb),
    )
  }

  async watchProject({ root }) {
    const resp = await promisify(cb => this.client.command(["watch-project", root], cb))

    if ("warning" in resp) {
      console.log("Watchman[WARNING]:", resp.warning)
    }

    /* console.log("watch established on", resp.watch) */

    return { resp }
  }

  async subscribe({ root, name, sub }) {
    const resp = await promisify(cb => this.client.command(["subscribe", root, name, sub], cb))

    if ("warning" in resp) {
      console.log("Watchman[WARNING]:", resp.warning)
    }

    return { resp }
  }

  stop() {
    this.client.removeAllListeners("subscription")
    this.client.end()
  }
}

class ProcessManager {
  constructor() {
    this.promiseChain = Promise.resolve()
    this.shouldExit = false
  }

  schedule(processFn) {
    if (this.shouldExit) return

    this.promiseChain = this.promiseChain
      .then(() => {
        if (this.shouldExit) return false
        return processFn()
      })
      .catch(err => {
        console.error(`Error from ${processFn}:`, err)
      })
  }

  exit() {
    this.shouldExit = true
    return this.promiseChain
  }
}

const root = path.dirname(__dirname)
const procManager = new ProcessManager()

const standardExclusions = [
  ["not", ["ipcre", "^(node_modules|tmp|log|public)", "wholename"]],
  ["not", ["ipcre", "^\\.#"]],
]

const prettierConfig = {
  name: "prettier",
  config: {
    expression: [
      "allof",
      [
        "anyof",
        ["ipcre", "\\.(jsx?|json|ya?ml)$"],
        ["match", ".eslintrc"],
        ["match", ".babelrc"],
        ["match", "test-watch"],
      ],
      ...standardExclusions,
    ],
    fields: ["name", "exists"],
  },
  handlers: [
    ({ files }) => {
      const runList = []
      const runAll = files.some(file => {
        if (path.basename(file.name) === ".prettierrc.js") return true
        if (file.exists) runList.push(file.name)
        return false
      })
      if (runList.length === 0) return
      if (runAll) {
        procManager.schedule(runPrettierAll)
      } else {
        procManager.schedule(() => runPrettier(runList))
      }
    },
  ],
}

const lintConfig = {
  name: "lint",
  config: {
    expression: [
      "allof",
      ["anyof", ["ipcre", "(\\.jsx?|\\.eslintrc)$"], ["match", "test-watch"]],
      ...standardExclusions,
    ],
    fields: ["name", "exists"],
  },
  handlers: [
    ({ files, is_fresh_instance: isFresh }) => {
      if (isFresh) {
        procManager.schedule(runLintAll)
        return
      }
      const filesToLint = files
        .filter(f => f.exists)
        .map(f => (path.basename(f.name) === ".eslintrc" ? path.dirname(f.name) : f.name))
      if (filesToLint.length === 0) return
      procManager.schedule(() => runLint(filesToLint))
    },
  ],
}

const testConfig = {
  name: "test",
  config: {
    expression: [
      "allof",
      ["anyof", ["ipcre", "^app/javascript/", "wholename"], ["ipcre", "^test-.+", "wholename"]],
      ["ipcre", ".jsx?$"],
      ...standardExclusions,
    ],
    fields: ["name", "exists"],
  },
  handlers: [
    ({ files }) => {
      const testFiles = []
      const runAll = files.some(file => {
        const isTestFile = testFilePattern.test(file.name)
        if (!isTestFile) return true // if event includes any non-tests, short-circuit .some() to exit iteration and runAll = true
        if (file.exists) testFiles.push(file.name) // still existing test file, add to list
        return false
      })

      if (!runAll && testFiles.length === 0) return
      if (runAll) {
        procManager.schedule(runJestAll)
      } else {
        procManager.schedule(() => runJest(testFiles))
      }
    },
  ],
}

const watchmanManager = new WatchmanManager([
  {
    root,
    subscriptions: [prettierConfig, lintConfig, testConfig],
  },
])
watchmanManager.start()

function exit() {
  console.log("exiting...")
  watchmanManager.stop()
  procManager.exit()
  process.stdin.pause()
  /* process.stdin.removeAllListeners("data") */
  /* process.exit() */
}

process.stdin.resume()
process.stdin.setEncoding("utf8")
process.stdin.on("data", chunk => {
  switch (chunk.trim()) {
    case "":
      procManager.schedule(runPrettierAll)
      procManager.schedule(runLintAll)
      procManager.schedule(runJestAll)
      break
    case "t":
      procManager.schedule(runJestAll)
      break
    case "p":
      procManager.schedule(runPrettierAll)
      break
    case "l":
      procManager.schedule(runLintAll)
      break
    case "q":
      exit()
      break
    default:
      console.log({ chunk })
  }
})

process.on("SIGINT", exit)
