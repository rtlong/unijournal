#!/usr/bin/env node -r babel-register

import path from 'path'
import { spawn } from 'child_process'
import Faucet from 'faucet'
import tapMin from 'tap-min'
import Watchman from 'fb-watchman'

const testFilePattern = /\.test\.jsx?$/

let testFormatter = tapMin

function buildFaucet() {
  return Faucet({
    width: process.stdout.isTTY ? process.stdout.columns - 5 : 0,
  })
}

function setTestFormatter(formatter) {
  testFormatter = formatter
  switch (formatter) {
    case tapMin:
      console.log('Tests formatted using tap-min')
      break
    case buildFaucet:
      console.log('Tests formatted using faucet')
      break
    case false:
      console.log('Tests unformatted')
      break
    default:
      throw new Error(`Unknown test formatter ${formatter}`)
  }
}

function runLinter(files) {
  return new Promise((resolve, reject) => {
    const cmd = ['node_modules/.bin/eslint', '--ext', 'js,jsx', ...files]
    console.log('Running ESLint', ...files)
    spawn(process.execPath, cmd, { stdio: 'inherit' })
      .on('error', err => {
        console.error(`error spawning ${cmd[0]}`, err)
        reject(err)
      })
      .on('exit', code => {
        console.error(`ESLint exited ${code}`)
        return resolve()
      })
  })
}

function runLintAll() {
  return runLinter('.')
}

function runTape(testFiles) {
  return new Promise((resolve, reject) => {
    const cmd = ['node_modules/.bin/tape', '-r', 'babel-register', ...testFiles]
    console.log('Running Tape', ...testFiles)
    // run Tape process
    const tape = spawn(process.execPath, cmd, { stdio: ['ignore', 'pipe', process.stderr] })
      .on('error', err => {
        console.error(`error spawning ${cmd[0]}`, err)
        reject(err)
      })
      .on('exit', code => {
        console.error(`Tape exited ${code}`)
        return resolve()
      })

    let { stdout } = tape
    // pipe output through faucet and to stdout
    if (testFormatter) {
      stdout = stdout.pipe(testFormatter())
    }
    stdout.pipe(process.stdout)
  })
}

function runAllTests() {
  return runTape(['app/javascript/**/*.test.js?(x)'])
}

function promisify(fn) {
  return new Promise((resolve, reject) => {
    const cb = (error, response) => {
      // console.log({error, response})
      if (error) {
        reject(error)
      } else {
        resolve(response)
      }
    }
    fn(cb)
  })
}

function initWatchman() {
  const watchman = new Watchman.Client()
  return promisify(cb => watchman.capabilityCheck({ optional: [], required: ['term-ipcre'] }, cb))
    .then(() => watchman)
    .catch(err => {
      console.error(err)
      process.exit(1)
    })
}

function watchProject({ watchman, root }) {
  return promisify(cb => watchman.command(['watch-project', root], cb))
    .then(resp => {
      if ('warning' in resp) {
        console.log('warning: ', resp.warning)
      }
      console.log('watch established on', resp.watch)
      return { watchman, resp }
    })
    .catch(error => {
      console.error('Error creating watch:', error)
      process.exit(1)
    })
}

function subscribe({ watchman, root, name, sub }) {
  return promisify(cb => watchman.command(['subscribe', root, name, sub], cb))
    .then(resp => {
      if ('warning' in resp) {
        console.log('warning: ', resp.warning)
      }
      return { resp, watchman }
    })
    .catch(error => {
      console.error('Error creating subscription:', error)
      process.exit(1)
    })
}

function setupWatchmanSubscriptionHandlers(watchman, scheduleProcess) {
  watchman.on('subscription', ({ subscription, files }) => {
    if (subscription !== 'test') return
    const testFiles = []
    const runAll = files.some(file => {
      const isTestFile = testFilePattern.test(file.name)
      if (!isTestFile) return true // if event includes any non-tests, short-circuit .some() to exit iteration and runAll = true
      if (file.exists) testFiles.push(file.name) // still existing test file, add to list
      return false
    })

    scheduleProcess(() => (runAll ? runAllTests() : runTape(testFiles)))
  })
  watchman.on('subscription', ({ subscription, files }) => {
    if (subscription !== 'lint') return
    const filesToLint = files
      .filter(f => f.exists)
      .map(f => (path.basename(f.name) === '.eslintrc'
               ? path.dirname(f.name)
               : f.name))
    scheduleProcess(() => runLinter(filesToLint))
  })
}

class ProcessManager {
  constructor() {
    this.promiseChain = Promise.resolve()
  }

  schedule(processFn) {
    this.promiseChain = this.promiseChain
                            .then(() => processFn())
                            .catch(err => {
                              console.error(`Error from ${processFn}:`, err)
                            })
  }
}

const root = path.dirname(__dirname)
const procManager = new ProcessManager()

const watchmanP = initWatchman()
  .then(watchman => watchProject({ watchman, root }))
  .then(args => {
    const { watchman } = args
    const scheduleProcess = proc => { procManager.schedule(proc) }
    setupWatchmanSubscriptionHandlers(watchman, scheduleProcess)
    return args
  })

watchmanP.then(({ watchman }) => {
  const sub = {
    expression: [
      'allof',
      ['ipcre', '.jsx?$'],
      ['not', ['ipcre', '^node_modules', 'wholename']],
      ['not', ['ipcre', '^\\.#']],
    ],
    fields: ['name', 'exists'],
  }
  return subscribe({
    watchman,
    sub,
    root,
    name: 'test',
  })
})

watchmanP.then(({ watchman }) => {
  const sub = {
    expression: ['allof',
                 ['anyof',
                  ['ipcre', '(\\.jsx?|\\.eslintrc)$'],
                  ['match', 'test-watch']],
                 ['not', ['ipcre', '^node_modules', 'wholename']],
                 ['not', ['ipcre', '^\\.#']]],
    fields: ['name', 'exists'],
  }
  return subscribe({
    watchman,
    sub,
    root,
    name: 'lint',
  })
})

process.stdin.resume()
process.stdin.setEncoding('utf8')
process.stdin.on('data', chunk => {
  switch (chunk.trim()) {
    case '':
    case 't':
      procManager.schedule(() => runAllTests())
      break
    case 'l':
      procManager.schedule(() => runLintAll())
      break
    case 'f':
      switch (testFormatter) {
        case false:
          setTestFormatter(buildFaucet)
          break
        case tapMin:
          setTestFormatter(false)
          break
        default:
          setTestFormatter(tapMin)
      }
      break
    case 'f raw':
      setTestFormatter(false)
      break
    case 'f min':
      setTestFormatter(tapMin)
      break
    case 'f faucet':
      setTestFormatter(buildFaucet)
      break
    case 'q':
      console.log('exiting...')
      process.exit(0)
      break
    default:
      console.log({ chunk })
  }
})
