#!/usr/bin/env node -r babel-register

import path from "path"
import { spawn } from "child_process"

import chalk from "chalk"
import Watchman from "fb-watchman"

const testFilePattern = /\.test\.jsx?$/

function spawnProcessP({ name, args, execName = process.execPath }) {
  return new Promise((resolve, reject) => {
    /* console.log({ name, execName, args }) */
    console.log(
      chalk.blue(
        `>>> ${name}: ${execName === process.execPath ? "node" : execName} ${args.join(" ")}`,
      ),
    )
    spawn(execName, args, { stdio: "inherit" })
      .on("error", err => {
        console.error(`error spawning ${name}`, err)
        reject(err)
      })
      .on("exit", code => {
        if (code === 0) {
          console.error(chalk.green(`<<< ${name} succeeded`))
        } else {
          console.error(chalk.red(`<<< ${name} exited ${code}`))
        }
        return resolve()
      })
  })
}

function promisify(fn) {
  return new Promise((resolve, reject) => {
    const cb = (error, response) => {
      // console.log({error, response})
      if (error) {
        reject(error)
      } else {
        resolve(response)
      }
    }
    fn(cb)
  })
}

class WatchmanManager {
  constructor(roots) {
    this.client = new Watchman.Client()
    this.roots = roots
  }

  async start() {
    await this.init()
    this.roots.forEach(async rootConfig => {
      const { root, subscriptions } = rootConfig
      await this.watchProject({ root })
      subscriptions.forEach(async ({ name, config, handlers = [] }) => {
        handlers.forEach(handler => {
          this.client.on("subscription", event => {
            const { subscription } = event
            if (subscription !== name) return
            /* console.log({ subscription, files: event.files }) */
            handler(event)
          })
        })
        await this.subscribe({ root, sub: config, name })
      })
    })
  }

  init() {
    return promisify(cb =>
      this.client.capabilityCheck({ optional: [], required: ["term-ipcre"] }, cb),
    )
  }

  async watchProject({ root }) {
    const resp = await promisify(cb => this.client.command(["watch-project", root], cb))

    if ("warning" in resp) {
      console.log("Watchman[WARNING]:", resp.warning)
    }

    /* console.log("watch established on", resp.watch) */

    return { resp }
  }

  async subscribe({ root, name, sub }) {
    const resp = await promisify(cb => this.client.command(["subscribe", root, name, sub], cb))

    if ("warning" in resp) {
      console.log("Watchman[WARNING]:", resp.warning)
    }

    return { resp }
  }

  stop() {
    this.client.removeAllListeners("subscription")
    this.client.end()
  }
}

class RunList {
  constructor() {
    this.list = new Set()
  }

  reset() {
    this.list.clear()
    this.all = false
  }

  runAll() {
    this.all = true
  }

  concat(files) {
    files.forEach(f => this.list.add(f))
  }

  value() {
    if (this.all) return "all"
    return Array.from(this.list)
  }

  any() {
    if (this.all) return true
    return this.list.size > 0
  }
}

class ProcessManager {
  constructor() {
    this.shouldExit = false
    this.queues = {} // keyed by process type, values are args to run next time we run this process type
    this.processes = {}
    this.process_priority = []
    this.timeout = null
  }

  schedule(type, files) {
    if (this.shouldExit) return
    if (!(type in this.processes)) throw new Error(`Process type ${type} is not known`)

    if (files === "all") {
      this.queues[type].runAll()
    } else {
      this.queues[type].concat(files)
    }

    /* console.log({ queues: JSON.stringify(this.queues, 2) }) */
    if (!this.timeout) {
      this.timeout = setTimeout(() => this.runNext(), 100)
    }
  }

  async runNext() {
    if (this.shouldExit) return

    const type = this.process_priority.find(t => this.queues[t].any())

    if (!type) {
      this.timeout = null
      return
    }

    const proc = this.processes[type]
    let files = this.queues[type].value()
    if (files === "all") files = proc.allArgs
    const args = proc.argsFn(files)

    this.queues[type].reset()

    await spawnProcessP({
      name: type,
      execName: proc.execPath,
      args,
    })

    this.timeout = setTimeout(() => this.runNext(), 100)
  }

  defineProcess(type, { argsFn, execPath = process.execPath, allArgs = [] }) {
    if (type in this.processes) throw new Error(`Process "${type}" is already defined!`)
    this.processes[type] = {
      argsFn,
      execPath,
      allArgs,
    }
    this.process_priority.push(type)
    this.queues[type] = new RunList()
    return this
  }

  exit() {
    this.shouldExit = true
    return this.promiseChain
  }
}

const root = path.dirname(__dirname)
const procManager = new ProcessManager()
  .defineProcess("Prettier", {
    argsFn: files => ["node_modules/.bin/prettier", "--loglevel", "warn", "--write", ...files],
    allArgs: [".babelrc", ".eslintrc", "bin/test-watch", "**/*.{js,jsx,json,yaml,md}"],
  })
  .defineProcess("ESLint", {
    argsFn: files => ["node_modules/.bin/eslint", "--ext", "js,jsx", ...files],
    allArgs: ["."],
  })
  .defineProcess("Jest", {
    argsFn: files => ["node_modules/.bin/jest", ...files],
    allArgs: [],
  })

const standardExclusions = [
  ["not", ["ipcre", "^(node_modules|tmp|log|public)", "wholename"]],
  ["not", ["ipcre", "^\\.#"]],
]

const prettierConfig = {
  name: "prettier",
  config: {
    expression: [
      "allof",
      [
        "anyof",
        ["ipcre", "\\.(jsx?|json|ya?ml)$"],
        ["match", ".eslintrc"],
        ["match", ".babelrc"],
        ["match", "test-watch"],
      ],
      ...standardExclusions,
    ],
    fields: ["name", "exists"],
  },
  handlers: [
    ({ files }) => {
      const runList = []
      const runAll = files.some(file => {
        if (path.basename(file.name) === ".prettierrc.js") return true
        if (file.exists) runList.push(file.name)
        return false
      })
      if (runList.length === 0) return
      if (runAll) {
        procManager.schedule("Prettier", "all")
      } else {
        procManager.schedule("Prettier", runList)
      }
    },
  ],
}

const lintConfig = {
  name: "lint",
  config: {
    expression: [
      "allof",
      ["anyof", ["ipcre", "(\\.jsx?|\\.eslintrc)$"], ["match", "test-watch"]],
      ...standardExclusions,
    ],
    fields: ["name", "exists"],
  },
  handlers: [
    ({ files, is_fresh_instance: isFresh }) => {
      if (isFresh) {
        procManager.schedule("ESLint", "all")
        return
      }
      const filesToLint = files
        .filter(f => f.exists)
        .map(f => (path.basename(f.name) === ".eslintrc" ? path.dirname(f.name) : f.name))
      if (filesToLint.length === 0) return
      procManager.schedule("ESLint", filesToLint)
    },
  ],
}

const testConfig = {
  name: "test",
  config: {
    expression: [
      "allof",
      ["anyof", ["ipcre", "^app/javascript/", "wholename"], ["ipcre", "^test-.+", "wholename"]],
      ["ipcre", ".jsx?$"],
      ...standardExclusions,
    ],
    fields: ["name", "exists"],
  },
  handlers: [
    ({ files }) => {
      const testFiles = []
      const runAll = files.some(file => {
        const isTestFile = testFilePattern.test(file.name)
        if (!isTestFile) return true // if event includes any non-tests, short-circuit .some() to exit iteration and runAll = true
        if (file.exists) testFiles.push(file.name) // still existing test file, add to list
        return false
      })

      if (!runAll && testFiles.length === 0) return
      if (runAll) {
        procManager.schedule("Jest", "all")
      } else {
        procManager.schedule("Jest", testFiles)
      }
    },
  ],
}

const watchmanManager = new WatchmanManager([
  {
    root,
    subscriptions: [prettierConfig, lintConfig, testConfig],
  },
])
watchmanManager.start()

function exit() {
  console.log("exiting...")
  watchmanManager.stop()
  procManager.exit()
  process.stdin.pause()
  /* process.stdin.removeAllListeners("data") */
  /* process.exit() */
}

process.stdin.resume()
process.stdin.setEncoding("utf8")
process.stdin.on("data", chunk => {
  switch (chunk.trim()) {
    case "":
      procManager.schedule("Prettier", "all")
      procManager.schedule("ESLint", "all")
      procManager.schedule("Jest", "all")
      break
    case "t":
      procManager.schedule("Jest", "all")
      break
    case "p":
      procManager.schedule("Prettier", "all")
      break
    case "l":
      procManager.schedule("ESLint", "all")
      break
    case "q":
      exit()
      break
    default:
      console.log({ chunk })
  }
})

process.on("SIGINT", exit)
