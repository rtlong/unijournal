#!/usr/bin/env node -r babel-register

import path from 'path'
import { spawn } from 'child_process'
import Watchman from 'fb-watchman'

const testFilePattern = /\.test\.jsx?$/

function runLinter(files) {
  return new Promise((resolve, reject) => {
    const cmd = ['node_modules/.bin/eslint', '--ext', 'js,jsx', ...files]
    console.log('Running ESLint', ...files)
    spawn(process.execPath, cmd, { stdio: 'inherit' })
      .on('error', err => {
        console.error(`error spawning ${cmd[0]}`, err)
        reject(err)
      })
      .on('exit', code => {
        console.error(`ESLint exited ${code}`)
        return resolve()
      })
  })
}

function runLintAll() {
  return runLinter('.')
}

function runTestProcess(testFiles) {
  return new Promise((resolve, reject) => {
    const cmd = ['node_modules/.bin/jest', ...testFiles]
    console.log('Running tests', ...testFiles)
    spawn(process.execPath, cmd, { stdio: ['ignore', process.stdout, process.stderr] })
      .on('error', err => {
        console.error(`error spawning ${cmd[0]}`, err)
        reject(err)
      })
      .on('exit', code => {
        console.error(`Tests exited ${code}`)
        return resolve()
      })
  })
}

function runAllTests() {
  return runTestProcess([])
}

function promisify(fn) {
  return new Promise((resolve, reject) => {
    const cb = (error, response) => {
      // console.log({error, response})
      if (error) {
        reject(error)
      } else {
        resolve(response)
      }
    }
    fn(cb)
  })
}

function initWatchman() {
  const watchman = new Watchman.Client()
  return promisify(cb => watchman.capabilityCheck({ optional: [], required: ['term-ipcre'] }, cb))
    .then(() => watchman)
    .catch(err => {
      console.error(err)
      process.exit(1)
    })
}

function watchProject({ watchman, root }) {
  return promisify(cb => watchman.command(['watch-project', root], cb))
    .then(resp => {
      if ('warning' in resp) {
        console.log('warning: ', resp.warning)
      }
      console.log('watch established on', resp.watch)
      return { watchman, resp }
    })
    .catch(error => {
      console.error('Error creating watch:', error)
      process.exit(1)
    })
}

function subscribe({ watchman, root, name, sub }) {
  return promisify(cb => watchman.command(['subscribe', root, name, sub], cb))
    .then(resp => {
      if ('warning' in resp) {
        console.log('warning: ', resp.warning)
      }
      return { resp, watchman }
    })
    .catch(error => {
      console.error('Error creating subscription:', error)
      process.exit(1)
    })
}

function setupWatchmanSubscriptionHandlers(watchman, scheduleProcess) {
  watchman.on('subscription', ({ subscription, files }) => {
    if (subscription !== 'test') return
    const testFiles = []
    const runAll = files.some(file => {
      const isTestFile = testFilePattern.test(file.name)
      if (!isTestFile) return true // if event includes any non-tests, short-circuit .some() to exit iteration and runAll = true
      if (file.exists) testFiles.push(file.name) // still existing test file, add to list
      return false
    })

    if (!runAll && testFiles.length === 0) return
    scheduleProcess(() => (runAll ? runAllTests() : runTestProcess(testFiles)))
  })

  watchman.on('subscription', ({ subscription, files }) => {
    if (subscription !== 'lint') return
    const filesToLint = files
      .filter(f => f.exists)
      .map(f => (path.basename(f.name) === '.eslintrc'
               ? path.dirname(f.name)
               : f.name))
    if (filesToLint.length === 0) return
    scheduleProcess(() => runLinter(filesToLint))
  })
}

class ProcessManager {
  constructor() {
    this.promiseChain = Promise.resolve()
  }

  schedule(processFn) {
    this.promiseChain = this.promiseChain
                            .then(() => processFn())
                            .catch(err => {
                              console.error(`Error from ${processFn}:`, err)
                            })
  }
}

const root = path.dirname(__dirname)
const procManager = new ProcessManager()

const watchmanP = initWatchman()
  .then(watchman => watchProject({ watchman, root }))
  .then(args => {
    const { watchman } = args
    const scheduleProcess = proc => { procManager.schedule(proc) }
    setupWatchmanSubscriptionHandlers(watchman, scheduleProcess)
    return args
  })

watchmanP.then(({ watchman }) => {
  const sub = {
    expression: [
      'allof',
      ['ipcre', '.jsx?$'],
      ['not', ['ipcre', '^(node_modules|tmp)', 'wholename']],
      ['not', ['ipcre', '^\\.#']],
    ],
    fields: ['name', 'exists'],
  }
  return subscribe({
    watchman,
    sub,
    root,
    name: 'test',
  })
})

watchmanP.then(({ watchman }) => {
  const sub = {
    expression: ['allof',
                 ['anyof',
                  ['ipcre', '(\\.jsx?|\\.eslintrc)$'],
                  ['match', 'test-watch']],
                 ['not', ['ipcre', '^(node_modules|tmp)', 'wholename']],
                 ['not', ['ipcre', '^\\.#']]],
    fields: ['name', 'exists'],
  }
  return subscribe({
    watchman,
    sub,
    root,
    name: 'lint',
  })
})

process.stdin.resume()
process.stdin.setEncoding('utf8')
process.stdin.on('data', chunk => {
  switch (chunk.trim()) {
    case '':
    case 't':
      procManager.schedule(() => runAllTests())
      break
    case 'l':
      procManager.schedule(() => runLintAll())
      break
    case 'q':
      console.log('exiting...')
      process.exit(0)
      break
    default:
      console.log({ chunk })
  }
})
